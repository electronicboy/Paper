From c5c8ec25c00ac3bbda8b6ee3fdfdd372b8bbac38 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Fri, 28 Sep 2018 20:46:29 -0400
Subject: [PATCH] Optimize Light Recalculations

The server triggers light recalculations even if the new block
is the same as the old block. At this time, BlockData Properties
do not impact light calculations.

So the only way light should change, is if the block itself
changes from 1 block to another.

Also optimizes to not repeatedly look up the same chunk for
light lookups.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index e04204055..0b54b7d78 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -523,6 +523,11 @@ public class PaperWorldConfig {
         log("ArmorStand ticking is " + (this.armorStandTick ? "enabled" : "disabled") + " by default");
     }
 
+    public boolean optimizeLight = true;
+    private void optimizeLight() {
+        this.optimizeLight = getBoolean("optimize-light", optimizeLight);
+    }
+
     public boolean antiXray;
     public boolean asynchronous;
     public EngineMode engineMode;
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index fb00e7a9c..fdf062b8b 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -353,7 +353,7 @@ public class Chunk implements IChunkAccess {
     private void a(int i, int j, int k, int l) {
         if (l > k && this.areNeighborsLoaded(1)) { // Paper
             for (int i1 = k; i1 < l; ++i1) {
-                this.world.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+                this.world.updateBrightness(EnumSkyBlock.SKY, new BlockPosition(i, i1, j), this); // Paper
             }
 
             this.x = true;
@@ -563,7 +563,7 @@ public class Chunk implements IChunkAccess {
             } else {
                 if (flag1) {
                     this.initLighting();
-                } else {
+                } else if (!world.paperConfig.optimizeLight || block != block1) { // Paper - Optimize light recalculations
                     this.runOrQueueLightUpdate(() -> { // Paper - Queue light update
                     int i1 = iblockdata.b(this.world, blockposition);
                     int j1 = iblockdata1.b(this.world, blockposition);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 2224eeab2..57de5f48a 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -591,8 +591,9 @@ public abstract class World implements IEntityAccess, GeneratorAccess, IIBlockAc
         }
 
         if (this.worldProvider.g()) {
-            for (i1 = k; i1 <= l; ++i1) {
-                this.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+            Chunk chunk = getChunkIfLoaded(i >> 4, j >> 4); // Paper
+            for (i1 = k; chunk != null && i1 <= l; ++i1) { // Paper
+                this.updateBrightness(EnumSkyBlock.SKY, new BlockPosition(i, i1, j), chunk); // Paper
             }
         }
 
@@ -2228,6 +2229,11 @@ public abstract class World implements IEntityAccess, GeneratorAccess, IIBlockAc
     public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
         // CraftBukkit start - Use neighbor cache instead of looking up
         Chunk chunk = this.getChunkIfLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+        // Paper start - optimize light updates where chunk is known
+        return updateBrightness(enumskyblock, blockposition, chunk);
+    }
+    public boolean updateBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition, Chunk chunk) {
+        // Paper end
         if (chunk == null || !chunk.areNeighborsLoaded(1) /*!this.areChunksLoaded(blockposition, 17, false)*/) {
             // CraftBukkit end
             return false;
-- 
2.21.0

